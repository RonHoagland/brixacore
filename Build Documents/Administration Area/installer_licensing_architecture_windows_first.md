# Installer & Licensing Architecture (Windows First)

## Purpose
Define the **offline licensing, activation, validation, and mode-switching behavior** for BrixaWares so installs are seamless for non-technical users while enforcing strict rules around Solo vs Multi-user usage.

This document intentionally covers **licensing only** (activation code format, validation rules, trial interaction, and mode-switch behavior). Website fulfillment and sales processes are out of scope.

This document is **authoritative** for licensing behavior.

---

## Core Principles
- Single installer per OS (Windows first)
- Double‑click install, minimal decisions
- No laptop may ever function as a server
- One database engine for all modes: **PostgreSQL**
- Solo and Multi‑user differ by **configuration**, not components
- Licensing controls mode; hardware eligibility enforces safety

---

## Installation Targets
- **Primary OS:** Windows (80%)
- macOS secondary (future)
- Linux deferred

---

## Hardware Detection Rules

### Battery Detection (Laptop Prevention)
- Installer checks for internal battery using Windows WMI/CIM:
  - `Win32_Battery`
  - `Win32_SystemEnclosure.ChassisTypes`
- **If battery detected → system is treated as a laptop**

### Enforcement
- **Laptop detected:**
  - Solo install **only**
  - Multi‑user installation and activation are blocked
- **No battery detected:**
  - Multi‑user is allowed (subject to license)

No overrides are exposed to end users.

---

## Installation Modes

### Solo Mode
- PostgreSQL installed locally
- Application binds to `127.0.0.1`
- No firewall rules created
- Single‑user behavior enforced
- Can operate as:
  - Trial (no key)
  - Licensed Solo

### Multi‑User Mode
- PostgreSQL installed locally
- Application binds to LAN interface (`0.0.0.0` or active NIC)
- Firewall rule added for application port (**Private networks only**)
- PostgreSQL **never exposed to LAN**
- Multi‑user features enabled (user management, concurrency)

---

## Licensing Behavior

### License Entry
- License key entry is supported **inside the application**
- Installer does **not require** a key

### License Format (Locked)
- Users enter/paste an **Activation Code** (typed/pasted)
- Activation code decodes to a **signed license payload**
- App verifies signature offline using an embedded **public key**

### Payload Schema (v1)
This system uses a **compact binary payload** (not JSON) to keep the activation code reasonably short while remaining **fully offline** and **self-contained**.

### Binary Payload Layout (Schema v1)
All integers are **unsigned**, **big-endian**.

| Offset | Size | Type | Field | Notes |
|---:|---:|---|---|---|
| 0 | 2 | bytes | `magic` | Constant ASCII `BW` (0x42 0x57) |
| 2 | 1 | uint8 | `schema_version` | `1` |
| 3 | 1 | uint8 | `edition` | `1` = SOLO, `2` = MULTI |
| 4 | 1 | uint8 | `owned_major` | Major version owned (e.g., `1`, `2`, `3`) |
| 5 | 1 | uint8 | `flags` | Bitfield (reserved for future). Must be `0` for v1 unless explicitly defined later |
| 6 | 4 | uint32 | `issued_at` | Unix timestamp (seconds) UTC |
| 10 | 4 | uint32 | `maintenance_until` | Unix timestamp (seconds) UTC. `0` = no active maintenance |
| 14 | 8 | uint64 | `license_id` | Random unique ID for tracking/support (generated by licensing system) |
| 22 | 2 | uint16 | `crc16` | **CRC-16-CCITT-FALSE** over bytes 0–21 (magic through license_id). Used for fast typo detection |

**Payload length (v1):** 24 bytes

### What is signed
- `payload_signed_bytes` = bytes 0–23 (entire payload including `crc16`)
- Signature = Ed25519 signature over `payload_signed_bytes`

### What the activation code contains
- `activation_blob` = `payload_signed_bytes (24)` + `signature (64)`
- Total binary size = **88 bytes**

### Human-length expectation
- Base32 encoding of 88 bytes is typically ~**141 characters** (before adding separators/prefix)
- Shown in grouped format with dashes to improve readability and reduce transcription errors


- Signing algorithm: **Ed25519**
- App ships with embedded **public key** (no private key in the app, ever)
- Verification steps:
  1. Decode activation code → `{payload, signature}`
  2. Verify Ed25519 signature over the canonical payload bytes
  3. Validate payload fields (product match, schema_version supported, edition recognized)

### Canonicalization Rules (so signatures are stable)
- Payload must be serialized in a deterministic way before signing/verifying:
  - UTF-8
  - JSON with:
    - lexicographically sorted keys
    - no insignificant whitespace
    - no trailing commas
  - Dates/times must be ISO-8601 in UTC (`Z` suffix)

### Encoding Format (Activation Code)
Goal: easy paste/scan, low typo risk, offline decodable.

#### Binary container
- `activation_blob` = `payload_signed_bytes (24)` + `signature_bytes (64)`
- Total: **88 bytes**

#### String encoding
- Encode `activation_blob` using **Base32** (RFC 4648)
  - Uppercase only
  - No padding characters (`=`) in output

#### Presentation format (what the user sees)
- Prefix + grouped chunks (5 chars per group):
  - `BW1-AAAAA-BBBBB-CCCCC-DDDDD-EEEEE-FFFFF-GGGGG-HHHHH-IIIII-JJJJJ-KKKKK-LLLLL-MMMMM-NNNNN-OOOOO-PPPPP-QQQQQ-RRRRR-SSSSS-TTTTT-...`
- Rules:
  - The visible prefix is always `BW` + `<schema_version>` + `-` (e.g., `BW1-`)
  - After the prefix, groups are **exactly 5** Base32 characters separated by dashes
  - Input must accept:
    - with or without dashes
    - lowercase or uppercase
    - extra spaces (trim)

#### Length expectations (Schema v1)
- Base32 chars for 88 bytes ≈ **141 characters**
- With 5-char grouping:
  - 141 chars → 29 groups (28 full groups + 1 partial)
- With prefix + dashes, the displayed string will be roughly **175–185 characters** depending on final group size

#### QR Code content
- QR code encodes the **exact activation string** as shown (including the `BW1-` prefix and dashes)
- App should accept QR payload either:
  - exactly as encoded, or
  - without dashes/spaces (normalize during parsing)

#### Parsing / normalization
1. Trim leading/trailing whitespace
2. Uppercase
3. Remove spaces
4. If string starts with `BW` and includes dashes, keep only prefix for schema routing, then remove all dashes for decoding
5. Base32-decode the remaining characters into `activation_blob`

#### Fast validation (before crypto)
- Validate prefix `BW<digit>`
- Validate Base32 alphabet only (`A–Z2–7`)
- Base32 decode must yield exactly **88 bytes**
- Validate CRC-16 (CCITT-FALSE) in payload before signature verify (detects most typos quickly)

#### Signature validation
- Verify Ed25519 signature over `payload_signed_bytes` (24 bytes)

**Validation UX**
- As the user pastes/types the activation code:
  - After normalization + Base32 decode + CRC check passes, show a **green indicator**: “Code format looks good.”
  - This indicator appears **before** signature verification and does **not** mean the license is valid yet.
- Final validation outcomes:
  - **CRC fails:** “That code looks mistyped. Please check it and try again.”
  - **Signature fails:** “That code isn’t valid. Please double-check it or request a new one.”
  - **Wrong product/prefix/schema:** “That code is for a different product or version.”
  - **Multi-user attempted on laptop:** “Multi-user can’t be activated on a laptop. Install or activate Solo instead.”
- On successful validation:
  - Display edition (Solo / Multi-user)
  - Display owned major version
  -   - If Multi-user: inform user that a **service restart is required** and perform it automatically after confirmation.

---

## Scope Boundary
This document covers:
- Activation codes and QR payload format
- Offline verification (CRC + signature)
- Trial interaction (start/stop rules)
- Solo vs Multi-user enforcement rules
- User-facing activation UX messages

This document does **not** cover:
- Website purchase/fulfillment steps
- Payment processing
- Email/SMS delivery mechanics
- Back-office tooling

---

## License Reissue & Abuse Policy (Locked)

### Lost Activation Code
- **Action:** Re-send the original activation code to the purchaser.
- No regeneration or replacement is required.
- The same license remains valid.

### Stolen Activation Code
- **Action:** No remediation.
- Licenses are offline, self-contained, and not machine-bound.
- Revocation is intentionally not supported.
- This is an explicit business decision to avoid DRM complexity and user friction.

### License Transfer
- **Not applicable.**
- Licenses are not machine-bound and may be installed on any eligible machine.
- Solo vs Multi-user usage is enforced by license type and hardware rules, not by transfer mechanics.

---

