# Platform Core - Persistence and Metadata Standards

## Purpose

The **Persistence and Metadata Standards** define the universal data conventions that apply to **every table / entity** in every application and module built on the Platform Core.

This standard exists to ensure:

- Consistent behavior across modules
- Predictable querying and auditing
- Safer migrations and upgrades
- Reduced implementation variance and technical debt

This document defines **what must be built** and **how it must behave**, without prescribing implementation code.

---

## Scope

This document covers:

- Primary keys and identifier standards
- Required metadata fields
- Timestamp behavior
- User attribution behavior (created\_by, updated\_by)
- Soft delete / archive standards (framework-level)
- Database constraints and indexing expectations
- Data integrity rules and validation boundaries

This document does **not** cover:

- Business validation rules (those belong to modules)
- Workflow state machines (covered in Status & Lifecycle Framework)
- Reporting requirements
- Integration/API design

---

## Core Principles

1. **Consistency Is Mandatory**\
   Every module follows these standards; exceptions are not allowed.

2. **Deny Ambiguity**\
   Metadata fields must have deterministic meaning and behavior.

3. **Fail Closed**\
   When standards cannot be satisfied, writes must fail rather than silently degrade.

4. **Audit-Friendly by Default**\
   Records must retain enough history context to explain who did what and when.

---

## 1) Primary Key and Identifier Standards

### Primary Key Requirement

- Every table must have a single primary key named: **id**
- Primary key type: **UUID**
- UUID is generated by the system (not user-entered)

### External / Human-Readable IDs

- If a module requires a human-friendly identifier (e.g., “INV-2026-000123”), it must use:
  - A separate field (not the primary key)
  - The Numbering & Identity Services standard

### Uniqueness

- Primary key `id` must be globally unique within a deployment.

---

## 2) Required Metadata Fields (All Tables)

Every table must include the following fields:

### Timestamps

- **created\_at** (datetime)
- **updated\_at** (datetime)

### User Attribution

- **created\_by** (UUID referencing Users)
- **updated\_by** (UUID referencing Users)

### Record Status (Operational)

- **is\_active** (boolean)

> Note: `is_active` is not a workflow state. It is an operational flag used for disabling records without deleting them.

---

## 3) Timestamp Behavior

### created\_at

- Set once at record creation
- Never changes after creation

### updated\_at

- Updated on every successful modification
- Must not update on read-only operations

### System Time Source

- Timestamps are generated by the system, not accepted from the client.

---

## 4) User Attribution Behavior

### created\_by

- Set to the authenticated user who created the record
- Never changes after creation

### updated\_by

- Set to the authenticated user who last modified the record

### System/Automation Actions

If an automated system action creates/updates a record:

- `created_by` / `updated_by` must be set to a **system user** account (admin-defined).

---

## 5) Delete Standard (Hard Delete)

### Baseline Rule

- **Hard delete is the default behavior**.
- Hard delete must follow module-defined rules (what is deletable, and under what conditions).

### Hard Delete Requirements

When a record is deleted:

- The system must enforce referential integrity rules.
- **Default rule: deletion is restricted if dependent child records exist.**
- Cascade delete is **not permitted** unless explicitly defined and approved in the module specification.
- The system must record an audit/event entry for the delete action.
- The delete action must be permission-controlled,

---

## 6) Referential Integrity

### Foreign Keys

- Foreign keys should be enforced wherever practical.
- When a strict foreign key cannot be enforced (e.g., cross-module attachment patterns), the module must:
  - Enforce integrity at the application layer
  - Include indexed lookup fields to maintain performance

### Delete Rules

- Default rule: **restrict** deletion when child records exist.
- Modules must explicitly define any cascade behaviors.

---

## 7) Indexing Standards

### Required Indexes

- Primary key index on `id` (implicit)
- Index on `created_at`
- Index on `updated_at`

### Recommended Indexes

- Index on `is_active` where lists filter by active records
- Composite indexes for common query patterns (module-defined)

### Prohibited Patterns

- No reliance on full-table scans for standard list views.
- No “multi-key string” fields used as relationship substitutes.

---

## 8) Data Validation Boundaries

### Core-Level Validation

Core enforces:

- Required fields for metadata
- Type correctness
- UUID validity

### Module-Level Validation

Modules enforce:

- Business-required fields
- Range/format rules beyond basic types
- Cross-field rules (e.g., date1 must be before date2)

---

## 9) Concurrency and Update Safety

### Optimistic Concurrency (Recommended)

The platform should support an optimistic concurrency mechanism.

Standard approach (choose one in implementation):

- `row_version` integer incremented on update, OR
- `updated_at` comparison

If enabled, updates must fail with a clear conflict response when the record has changed since it was loaded.

---

## 10) Audit Compatibility

These metadata standards must align with the Security Auditing system:

- Audit events must be able to reference records by UUID
- created/updated attribution must be consistent with sessions and authentication

---

## Acceptance Criteria (Metadata Standards)

- Every table uses UUID primary key `id`.
- Every table contains the required metadata fields.
- created\_at/created\_by never change after creation.
- updated\_at/updated\_by update on every successful modification.
- Soft delete behavior is consistent where enabled.
- Referential integrity is preserved.
- Indexing supports standard list view queries.

---

## Build Assumptions & Locked Decisions

- UUID is the universal primary key type.
- Metadata fields are mandatory for all tables without exception.
- **Hard deletes are the standard delete behavior**; module specs must define deletion rules and constraints.
- System-generated timestamps are authoritative.
- `is_active` exists on all tables and represents operational enable/disable.

---

## Out of Scope (Explicit) (Explicit)

- Workflow state machines and transitions
- History/versioning of every field change (beyond audit events)
- Data warehouse or analytics structures
- API serialization formats

---

## Completion Definition

The Persistence and Metadata Standards are considered complete when:

- A developer can create any new table in any module and know exactly which metadata fields and behaviors are required.
- All modules can reliably build list/detail views that behave consistently.
- Data remains auditable and supportable without module-specific metadata conventions.

